<?php

namespace App\Scorpio;

use App\Entity\Sensor;
use App\IoTCrawler\SearchEnabler\Client as SearchEnablerClient;
use App\Repository\SensorRepository;
use App\Traits\LoggerTrait;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Serializer\SerializerInterface;

class SensorManager
{
    use LoggerTrait;

    /** @var Client */
    private $client;

    /** @var SensorRepository */
    private $sensorRepository;

    /** @var EntityManagerInterface */
    private $entityManager;

    /** @var SerializerInterface */
    private $serializer;

    /** @var array */
    private $options;

    public function __construct(Client $client, SearchEnablerClient $searchEnablerClient, SensorRepository $sensorRepository, EntityManagerInterface $entityManager, SerializerInterface $serializer, array $sensorManagerOptions)
    {
        $this->client = $client;
        $this->searchEnablerClient = $searchEnablerClient;
        $this->sensorRepository = $sensorRepository;
        $this->entityManager = $entityManager;
        $this->serializer = $serializer;

        $resolver = new OptionsResolver();

        $this->options = $resolver->resolve($sensorManagerOptions);
    }

    public function search(array $options = []): array
    {
        $sensorIds = null;
        if (isset($options['query']['observation_type'])) {
            $sensors = $this->searchEnablerClient->getSensorsByObservesType($options['query']['observation_type']);
            $sensorIds = array_column($sensors->sensors, 'id');
        }
        // Get sensor ids from search enabler.

        $query = $options['query']['q'] ?? $options['query']['query'] ?? '';
        $result = array_map(
            static function (Sensor $sensor) {
                return $sensor->getData()
                    ? $sensor->getData() + [
                        '_metadata' => $sensor->getSensorData(),
                    ]
                    : null;
            },
            $this->sensorRepository->search($query),
        );
        $result = array_filter($result);
        $result = array_column($result, null, 'id');

        if (null !== $sensorIds) {
            $result = array_filter($result, static function ($id) use ($sensorIds) {
                return in_array($id, $sensorIds, true);
            }, ARRAY_FILTER_USE_KEY);
        }

        if (isset($options['mission_sensors'])) {
            $missionSensors = $options['mission_sensors'];
            foreach ($result as $id => &$item) {
                $item['_metadata']['mission_sensor'] = $missionSensors[$id] ?? null;
            }
        }

        return [
            'options' => $options,
            'data' => array_values($result),
        ];
    }

    public function getSensors(array $criteria = [])
    {
        return $this->sensorRepository->findBy($criteria);
    }

    public function getSensor(string $id)
    {
        $sensor = $this->sensorRepository->find($id);

        if (null === $sensor) {
            $data = $this->client->getEntity($id);
            if (Client::ENTITY_TYPE_SENSOR === ($data['type'] ?? null)) {
                // Get stream generated by the sensor.
                $response = $this->client->getEntities([
                    'type' => Client::ENTITY_TYPE_STREAM,
                    'q' => sprintf('%s==%s', Client::ENTITY_ATTRIBUTE_GENERATED_BY, $data['id']),
                ]);
                if (Response::HTTP_OK === $response->getStatusCode()) {
                    $streams = $response->toArray();
                    if (1 !== count($streams)) {
                        throw new \RuntimeException(sprintf('Cannot get stream for sensor %s', $data['id']));
                    }
                    $stream = reset($streams);
                    // Get stream observation.
                    $response = $this->client->getEntities([
                        'type' => Client::ENTITY_TYPE_STREAM_OBSERVATION,
                        'q' => sprintf('%s==%s', Client::ENTITY_ATTRIBUTE_BELONGS_TO, $stream['id']),
                    ]);
                    if (Response::HTTP_OK === $response->getStatusCode()) {
                        $observations = $response->toArray();
                        if (1 !== count($observations)) {
                            throw new \RuntimeException(sprintf('Cannot get observation for stream %s', $stream['id']));
                        }
                        $observation = reset($observations);

                        $sensor = (new Sensor())
                            ->setId($id)
                            ->setData($data)
                            ->setStream($stream)
                            ->setStreamObservation($observation);
                        $this->entityManager->persist($sensor);
                        $this->entityManager->flush();
                    }
                }
            }
        }

        if (null === $sensor) {
            throw new \RuntimeException(sprintf('Invalid sensor id: %s', $id));
        }

        return $sensor;
    }

    public function updateSensors()
    {
        foreach ($this->options['types'] as $type) {
            $query = ['type' => $type];
            $response = $this->client->getEntities($query);
            if (Response::HTTP_OK === $response->getStatusCode()) {
                $result = $response->toArray();
                foreach ($result as $data) {
                    if (isset($data['id'])) {
                        $id = $data['id'];
                        $sensor = $this->sensorRepository->find($data['id']);
                        if (null === $sensor) {
                            $sensor = (new Sensor())
                                ->setId($id);
                        }
                        $sensor
                            ->setData($data);
                        $this->entityManager->persist($sensor);
                        $sensors[] = $sensor;
                    }
                }
                $this->entityManager->flush();
            }
        }
    }

    /**
     * Get sensors.
     */
    public function updatePlatformSensors()
    {
        $sensorData = [];

        $response = $this->client->getEntities(['type' => 'http://www.w3.org/ns/sosa/Platform']);
        if (Response::HTTP_OK === $response->getStatusCode()) {
            $platforms = $response->toArray();
            foreach ($platforms as $platform) {
                $response = $this->client->getEntities([
                    'type' => Client::ENTITY_TYPE_SENSOR,
                    'q' => sprintf('%s==%s', Client::ENTITY_ATTRIBUTE_IS_HOSTED_BY, $platform['id']),
                ]);
                if (Response::HTTP_OK === $response->getStatusCode()) {
                    $sensorData[] = $response->toArray();
                }
            }
        }

        $sensorData = array_merge(...$sensorData);

        return $this->createSensors($sensorData);
    }

    /**
     * @return Sensor[]
     */
    private function createSensors(array $sensorData)
    {
        $sensors = [];
        foreach ($sensorData as $data) {
            if (isset($data['id'])) {
                $id = $data['id'];
                $sensor = $this->sensorRepository->find($data['id']);
                if (null === $sensor) {
                    $sensor = (new Sensor())
                        ->setId($id);
                }
                $this->updateSensorData($sensor);
                $this->entityManager->persist($sensor);
                $sensors[] = $sensor;
            }
        }
        $this->entityManager->flush();

        return $sensors;
    }

    public function updateSensorData(Sensor $sensor)
    {
        $data = $this->client->getEntity($sensor->getId());
        try {
            if (Client::ENTITY_TYPE_SENSOR === ($data['type'] ?? null)) {
                $sensor->setData($data);
                // Get stream generated by the sensor.
                $response = $this->client->getEntities([
                    'type' => Client::ENTITY_TYPE_STREAM,
                    'q' => sprintf('%s==%s', Client::ENTITY_ATTRIBUTE_GENERATED_BY, $data['id']),
                ]);
                if (Response::HTTP_OK === $response->getStatusCode()) {
                    $streams = $response->toArray();
                    if (1 !== count($streams)) {
                        throw new \RuntimeException(sprintf('Cannot get stream for sensor %s', $data['id']));
                    }
                    $stream = reset($streams);
                    $sensor->setStream($stream);

                    // Get stream observation.
                    $response = $this->client->getEntities([
                        'type' => Client::ENTITY_TYPE_STREAM_OBSERVATION,
                        'q' => sprintf('%s==%s', Client::ENTITY_ATTRIBUTE_BELONGS_TO, $stream['id']),
                    ]);
                    if (Response::HTTP_OK === $response->getStatusCode()) {
                        $observations = $response->toArray();
                        if (1 !== count($observations)) {
                            throw new \RuntimeException(sprintf('Cannot get observation for stream %s', $stream['id']));
                        }
                        $observation = reset($observations);

                        $sensor->setStreamObservation($observation);
                    }

                    // Get QoI
                    if (isset($stream[Client::ENTITY_ATTRIBUTE_QOI_HAS_QUALITY]['object'])) {
                        $qoi = $this->client->getEntity($stream[Client::ENTITY_ATTRIBUTE_QOI_HAS_QUALITY]['object']);
                        if ($qoi) {
                            $sensor->setQoi($qoi);
                        }
                    }
                }
            }
        } catch (\RuntimeException $exception) {
            $this->error($exception->getMessage());
        }
    }
}
